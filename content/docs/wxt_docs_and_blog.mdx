---
title: WXT Documentation 
description: This markdown file contains two distinct pieces of content about **WXT**: a comprehensive documentation article and a focused blog post on entrypoints.
img: https://unsplash.com/s/photos/website-banner
---

# Details on WXT Documentation

This markdown file contains two distinct pieces of content about **WXT**: a comprehensive documentation article and a focused blog post on entrypoints.

---

## Directive 1: Comprehensive Documentation on WXT

### Introduction

**WXT** is a modern framework for building browser extensions with ease and speed. It streamlines extension development by offering:

- **Modern tooling** with Vite and TypeScript.
- **Manifest V3 support** out of the box.
- **Framework-agnostic development**, allowing you to use React, Vue, Svelte, or vanilla JavaScript.
- **Hot Module Replacement (HMR)** for faster iteration during development.

The goal of WXT is to remove the boilerplate and complexity of building extensions, letting developers focus on functionality rather than configuration.

### Core Features

- **Declarative Manifest:** Define your manifest in TypeScript instead of manually editing `manifest.json`.
- **Automatic Permissions:** Permissions are inferred based on your entrypoints, reducing manual errors.
- **Intelligent Bundling:** Each entrypoint is bundled independently for optimal performance.
- **Hot Reloading:** Edit background scripts, content scripts, or popup UI and see changes instantly.
- **Cross-Browser Support:** Build extensions that run on Chrome, Firefox, and other Chromium-based browsers.

### Getting Started

Follow these steps to set up a new WXT project:

```bash
# Install WXT globally
npm install -g wxt

# Create a new project
wxt create my-extension

# Navigate into your project
cd my-extension

# Start development server
npm run dev
```

During development, WXT provides a local environment where your extension reloads automatically.

### Example: `wxt.config.ts`

```ts
import { defineConfig } from "wxt";

export default defineConfig({
  manifest: {
    name: "My First Extension",
    version: "1.0.0",
  },
});
```

### Use Cases

WXT is particularly effective for:

- **Productivity extensions** like note-taking or task managers.
- **Developer tools** integrating with Chrome DevTools.
- **Content customization** extensions (e.g., modifying web pages).
- **UI-driven extensions** with custom popups and options pages.

---

## Directive 2: Blog Post on WXT Entrypoints

### Introduction

When building a web extension, you’ll interact with multiple _entrypoints_. These are the scripts or pages where your extension code runs. Managing them can get messy—but WXT makes it clean and straightforward. Let’s dive into how entrypoints work in WXT.

### What Are Entrypoints?

In web extensions, an **entrypoint** is a distinct part of your extension that serves a specific role. Common entrypoints include:

- **Background**: Runs in the background, managing events and state.
- **Content**: Injected into web pages to interact with the DOM.
- **Popup**: The UI shown when the user clicks the extension icon.
- **Options**: A dedicated page for extension settings.
- **DevTools**: Custom panels or tools within the browser’s DevTools.

These entrypoints form the backbone of any extension.

### WXT’s Approach

WXT automatically detects entrypoints from your project’s `src/` directory. For example:

- `src/background.ts` → background script
- `src/content.ts` → content script
- `src/popup.html` → popup UI

No need to manually register them in `manifest.json`—WXT generates the correct configuration.

### Examples

#### Background Entrypoint

```ts
// src/background.ts
chrome.runtime.onInstalled.addListener(() => {
  console.log("Extension installed!");
});
```

#### Content Entrypoint

```ts
// src/content.ts
document.body.style.border = "5px solid red";
```

#### Popup Entrypoint

```html
<!-- src/popup.html -->
<html>
  <body>
    <h1>Hello from Popup!</h1>
    <script type="module" src="./popup.ts"></script>
  </body>
</html>
```

#### Options Entrypoint

```html
<!-- src/options.html -->
<html>
  <body>
    <h2>Options Page</h2>
    <script type="module" src="./options.ts"></script>
  </body>
</html>
```

### Configuring Entrypoints with `wxt.config.ts`

```ts
import { defineConfig } from "wxt";

export default defineConfig({
  entrypoints: {
    background: "src/background.ts",
    content: "src/content.ts",
    popup: "src/popup.html",
    options: "src/options.html",
  },
});
```

WXT will generate the appropriate manifest fields automatically.

### Best Practices

- **Keep entrypoints minimal**: Each entrypoint should handle only its specific role.
- **Use shared modules**: Place reusable logic in a `utils/` folder.
- **Plan scalability**: Organize entrypoints in subfolders (`src/content/`, `src/background/`) for larger projects.
- **Test separately**: Since each entrypoint runs in a different context, test them independently.

### Conclusion

Entrypoints are fundamental to extension development, but managing them by hand is tedious. WXT simplifies this process with automatic detection, smart configuration, and intuitive project structure. If you’re building extensions with multiple moving parts, WXT’s entrypoint system will keep your codebase clean and scalable.
